generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // uses connection pooling
}

enum InstanceType {
  mastodon
  misskey
  cherrypick
}

model user {
  id           Int      @id @default(autoincrement())
  account      String
  accountLower String
  hostName     String
  handle       String   @unique
  name         String[]
  token        String
  userId       String   /// Misskey/Mastodon 의 내부 ID
  profile      profile?
  jwtIndex     Int      @default(0)
  server       server   @relation(references: [instances], fields: [hostName], onUpdate: Cascade, onDelete: Cascade)

  blocking  blocking[]  @relation("blocks")
  following following[] @relation("user")
}

enum PostVisibility {
  public
  home
  followers
}

model profile {
  id                    Int            @id @default(autoincrement())
  answer                answer[]
  questions             question[]
  account               String
  handle                String         @unique
  name                  String[]
  stopNewQuestion       Boolean        @default(false)
  stopAnonQuestion      Boolean        @default(false)
  stopNotiNewQuestion   Boolean        @default(false)
  stopPostAnswer        Boolean        @default(false)
  avatarUrl             String
  questionBoxName       String         @default("질문함")
  lastFollowRefreshed   DateTime       @default("1996-12-19T16:39:57-08:00")
  user                  user           @relation(fields: [handle], references: [handle], onDelete: Cascade)
  defaultPostVisibility PostVisibility @default(public)
  wordMuteList          String[]       @default([])
}

model answer {
  id                   String   @id @default(cuid())
  question             String
  questioner           String?
  answer               String
  answeredAt           DateTime @default(now())
  answeredPersonHandle String
  answeredPerson       profile  @relation(fields: [answeredPersonHandle], references: [handle], onDelete: Cascade)
  nsfwedAnswer         Boolean

  @@index([answeredPersonHandle])
}

model question {
  id               Int      @id @default(autoincrement())
  question         String
  questioner       String?
  questionee       profile  @relation(fields: [questioneeHandle], references: [handle], onDelete: Cascade)
  questioneeHandle String
  questionedAt     DateTime @default(now())
  isAnonymous          Boolean  /// is Anonymous question?

  @@index([questioneeHandle])
}

model server {
  id            Int          @id @default(autoincrement())
  instances     String       @unique /// Server 의 Hostname
  instanceType  InstanceType @default(misskey)
  appSecret     String? /// Misskey App인증의 Secret Key
  client_id     String? /// Mastodon OAuth2 client ID
  client_secret String? /// Mastodon OAuth2 client secret

  user user[]

  @@index([instances])
}

model blocking {
  id            String   @id @default(cuid())
  blockeeHandle String   @db.VarChar(500)
  blockerHandle String   @db.VarChar(500)
  blocker       user     @relation("blocks", fields: [blockerHandle], references: [handle], onDelete: Cascade)
  createdAt     DateTime @default(now())
  hidden        Boolean  @default(false)
  imported      Boolean  @default(false)

  @@unique([blockeeHandle, blockerHandle, hidden, imported])
  @@index([blockerHandle, hidden])
  @@index([blockeeHandle, hidden])
  @@index([imported])
}

model following {
  id             String   @id @default(cuid())
  followerHandle String   @db.VarChar(500)
  follower       user     @relation("user", fields: [followerHandle], references: [handle], onDelete: Cascade)
  followeeHandle String   @db.VarChar(500)
  createdAt      DateTime @default(now())

  @@unique([followerHandle, followeeHandle])
  @@index([followeeHandle])
  @@index([followerHandle])
}
